// kurssikirjasto:
#include "rinn2015.h"
#include "client.h"
#include "semafori.hh"
// c++11 kirjastoja:
#include <iostream>
#include <memory>
#include <cstdint>
#include <string>
#include <sstream>
#include <chrono>
#include <deque>
#include <queue>
#include <vector>
#include <fstream>
//For sleeping
#include <unistd.h>

// Eli sille lokikirjoittajalle on nyt tehty pohja, se tosin vain tulostaa
// näytölle kun en ulkomuistista osannut tehdä sitä tiedostoon kirjoittamista.
// Se toinen puskuri on nyt kuitenkin tehty.


const int OPNRO = 218948;
const int PUSKURIN_KOKO = 100;
const int PUSKURIN_2_KOKO = 100;
const int TUOTTAJASAIKEITA = 5;
const int KULUTTAJASAIKEITA = 1;


namespace {
   //Buffer http-yhteyksien tallentamiseen
   std::queue<std::unique_ptr<rinn2015::Client>> buffer;

   enum Virhekoodi 
     {
	OK,
	FAIL // 404 Not Found
	// tähän voi lisätä muutakin jos tarvitsee
     };

   
   struct Yhteys {
      Virhekoodi koodi;
      uint32_t ID;
      std::vector<std::string> polku; // pyydetyn dokumentin polku
   };
         
   std::queue<Yhteys> buffer2;

   semafori tuottaja_semafori(PUSKURIN_KOKO, "tuottaja");
   semafori kuluttaja_semafori(-1, "kuluttaja");

   semafori lukija_semafori(PUSKURIN_2_KOKO, "lukija");
   semafori kirjoittaja_semafori(-1, "kirjottaja");


   pthread_mutex_t yhteys_mutex;

   // Kellotusta varten
   std::clock_t start;
   double duration;

   // testitulostuksia varten
   int yhteyksia_palveltu = 0;
}

// Nopeus yhdellä tuottaja- ja yhdellä kuluttajasäikeellä:
// 1000 yhteyttä (duration 20s): ~25,5s
// sarjallisella mallikoodilla sama 36s





// Tuottaja hakee uusia http-yhteyksiä palvelimelta
void* Tuottaja(void* arg){
   long int id = reinterpret_cast<long int>(arg);
   
   while(true){
      std::cout << "Tuottaja: " << id <<" buffer: " << buffer.size() <<std::endl;
      // Haetaan yksi http-yhteys käsittelyyn
      pthread_mutex_lock(&yhteys_mutex);
      std::unique_ptr<rinn2015::Client> client( rinn2015::get_connection() );
      std::cout << "Connection saatu tuottajalta: " << id <<" buffer: " << buffer.size() <<std::endl;
      pthread_mutex_unlock(&yhteys_mutex);
      
      // Lukitaan puskurin mutex.
      tuottaja_semafori.lukitse();

      // lisätään alkio puskuriin.
      buffer.push(std::move(client));
      std::cout << "Connection lisatty tuottajalta: " << id <<" buffer: " << buffer.size() <<std::endl;
      // herätetään kuluttaja
      kuluttaja_semafori.signaloi();

      // avataan mutex
      tuottaja_semafori.avaa();
   }
   
}
//Kuluttaja palvelee bufferiin lisätyt yhteydet
void* Kuluttaja(void* arg){
	
   long int id = reinterpret_cast<long int>(arg);
   
   while(true){
      std::cout << "Kuluttaja: " << id <<" buffer: "<< buffer.size() <<std::endl; 
      // Lukitaan puskurin mutex
      kuluttaja_semafori.lukitse();

      // Otetaan alkio puskurista. Koska kyseessä on unique_ptr, täytyy käyttää
      // move-funktiota.
      std::unique_ptr<rinn2015::Client> client(std::move(buffer.front()));
      buffer.pop();
      // herätetään tuottaja
      tuottaja_semafori.signaloi();
      // avataan mutex
      kuluttaja_semafori.avaa();
      
      // Luodaan yhteysmuuttuja myöhempää lokikirjoitusta varten.
      Yhteys yhteys;
      
      // Tutkitaan clientin path-osiota (eli pyydetyn dokumentin nimeä),
      // ja jos se löytyy työhakemistosta, lähetetään se.
      
      std::string polku;
      // Muunnetaan ensin path stringiksi
      for (unsigned int i = 0; i < client->path.size(); ++i) {
	 polku += "/";
	 polku += client->path.at(i);
      }
      // Yritetään avata tiedosto luettavaksi.
      
      std::ifstream tiedosto(polku);
            
      if (tiedosto) {
	 // Avaus onnistui, eli tiedosto oli tunnettu -> rakennetaan onnistuneet vastaustiedot
	 client->reply_status = "200";
	 std::stringstream vastaus;
	 vastaus << tiedosto; // toimiikohan tämä näin?
	 client->reply_data = vastaus.str();
	 // Kirjataan yhteyden tietoihin, että se palveltiin
	 yhteys.koodi = OK;
      }
      else {
	 // Ei ollut tunnettu -> palautetaan 404 Not Found ja muokataan
	 // lokikirjoituksen tiedot samoin.
	 client->reply_status = "404";
//	 std::stringstream vastaus;
//	 vastaus << "<html> <body>"
//	   << "<h1> Hello World! </h1>"
//	   << "</body> </html>";
	 client->reply_data = ""; // tähän ei kai tule mitään?
	 // Kirjataan yhteyden tietoihin, että ei palveltu
	 yhteys.koodi = FAIL;
      }
      // Lisätään pyydetyn dokumentin polku yhteyden tietoihin.
      yhteys.polku = client->path;
	 
      // lähetetään vastaus kirjaston avulla (tämä on säieturvallista, 
      // joten mutexia ei tarvita.)
	 
      // Tämä heittää poikkeuksen, jos echo-käskyn timeout ei ole riittävä
      // duration-aikaan nähden. 
      
      uint32_t clientId = rinn2015::send_reply( std::move(client) );
      //usleep( 1 * 1000 * 100 );
      ++yhteyksia_palveltu;

      yhteys.ID = clientId;      

      /*lukitaan lukija*/
      lukija_semafori.lukitse();

      // lisätään alkio puskuriin.
      buffer2.push(yhteys);
      
      // herätetään kirjoittaja
      kirjoittaja_semafori.signaloi();
      
      // avataan mutex
      lukija_semafori.avaa();  
        
      //Aputulostus: kertoo missä säikeessä kuluttaja toimi
      
      //Aputulostus: kertoo miten bufferin koko muuttuu
      // std::cout << "Kuluttaja: " << id <<" buffer: "<< puskurin_koko 
      //	<< std::endl << "yhteyksiä palveltu: " << yhteyksia_palveltu 
      //	<< std::endl;
      
      // Tulostetaan lopuksi kulunut aika
      if (yhteyksia_palveltu >= 498) {
	 // Tähän otettu mallia: 
	 // http://stackoverflow.com/questions/3220477/how-to-use-clock-in-c
	 // (linkistä huolimatta kyse c++:sta)
	 duration = ( std::clock() - start ) / (double) CLOCKS_PER_SEC;
	 std::cout << "Aikaa meni: " << duration << std::endl;
      }	 
      
   }
   
}

// Lokikirjoittaja saa kuluttajalta buffer2:n välityksellä id:n ja viestin, 
// jonka perusteella se kirjoittaa lokitiedostoon tiedot käsitellystä 
// yhteydestä, tai mahdollisesti siitä, mikä meni pieleen.

void* Lokikirjoittaja(void* arg) {

   // Luodaan tiedostovirtamuuttuja
   
   std::ofstream loki;
   
   // Avataan tiedosto.

   loki.open("HTTP.LOKI");
   
   while (true) {
      // Otetaan puskurista tiedot ja kirjoitetaan rivi tiedostoon
      kirjoittaja_semafori.lukitse();

      // Otetaan alkio puskurista.
      Yhteys yhteys = buffer2.front();
      buffer2.pop();
         
      // herätetään lukija
      lukija_semafori.signaloi();

      // avataan mutex
      kirjoittaja_semafori.avaa();     
      
      // Tarkistetaan, että tiedosto on auki. Jos ei, virheilmoitus ja exit
      if (! loki.is_open()) {
	 std::cerr << "Tiedosto ei ollut auki." << std::endl;
	 exit(EXIT_FAILURE);
      }
      // Jos tiedosto oli auki, kirjoitetaan sinne mitä tehtiin. Erotellaan onnistunut
      // ja epäonnistunut tapaus.
      
      if (yhteys.koodi == OK) {
	 // Yhteys palveltiin onnistuneesti.      
	 loki << "Palveltiin yhteys: " << rinn2015::peer_info( yhteys.ID )
	   << std::endl << "Polku oli: ";
	 // tulostetaan polku
	 for (unsigned int i = 0; i < yhteys.polku.size(); ++i) {
	    loki << "/" << yhteys.polku.at(i);
	 }
	 loki << std::endl;
	    
	 
      }
      else if (yhteys.koodi == FAIL) {
	 // Yhteyden palveleminen epäonnistui.
	 loki << "Yhteys pyysi tuntematonta dokumenttia: " << rinn2015::peer_info( yhteys.ID )
	   << std::endl;
	 // tulostetaan polku
	 for (unsigned int i = 0; i < yhteys.polku.size(); ++i) {
	    loki << "/" << yhteys.polku.at(i);
	 }
	 loki << std::endl;
      }
      
   }
   
}

int main() {
   try {
      start = std::clock();
      
      // alustetaan mutex 
      pthread_mutex_init(&yhteys_mutex, 0);

      // 1. alustetaan kirjasto omalla opiskelijanumerolla
      rinn2015::init_server( OPNRO );

      std::vector<pthread_t> tuottajat;
      std::vector<pthread_t> kuluttajat;

      //Tuottaja-säikeet käyntiin ja tunniste talteen taulukkoon
      for( auto i = 1; i <= TUOTTAJASAIKEITA; i++ ) {
      	 auto num = reinterpret_cast<void*>( i );
      	 pthread_t saie;
      	 auto status = pthread_create( &saie, NULL, &Tuottaja, num );
      	 if( status != 0 ) {
                  perror( "pthread_create" );
                  exit(1);
      	 }
      	 tuottajat.push_back( saie );
      }

      //Kuluttaja-säikeet käyntiin ja tunniste talteen taulukkoon
      for( auto i = 1; i <= KULUTTAJASAIKEITA; i++ )
   	{
   	   auto num = reinterpret_cast<void*>( i );
   	   pthread_t saie;
   	   auto status = pthread_create( &saie, NULL, &Kuluttaja, num );
   	   if( status != 0 ) {
   	      perror( "pthread_create" );
   	      exit(1);
   	   }
   	   kuluttajat.push_back( saie );
   	}
      // Lokikirjoittaja käyntiin
      pthread_t lokikirjoittaja;
      int i = TUOTTAJASAIKEITA + KULUTTAJASAIKEITA + 1;      
      auto num = reinterpret_cast<void*>( i );      
      auto status  = pthread_create( &lokikirjoittaja, NULL, &Lokikirjoittaja,
				     num );
      if( status != 0 ) {
      	 perror( "pthread_create" );
      	 exit(1);
      }
      
      // ohjelma jää looppaamaan tähän, ellei poikkeuksia tule
      while( true ) {
	 
      }

   } catch( std::exception &e ) {
      std::cerr << "exception in main(): " << e.what() << std::endl;
   }
}
